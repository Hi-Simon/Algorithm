## 字符串算法-个人总结

### Manacher算法

此算法用于求最长回文字串，时间复杂度为$O(n)$。

令$j=2*id-i$，$j$代表$i$关于$id$对称的位置，

若$mx-i>p[j]$，则以$i$为中心的最长回文字串一定被包含于以$id$为中心的回文字串中，又因为$[id-mx,id+mx]$是回文字串，所以一定有$p[i]=p[j]​$。

![img](https://img2018.cnblogs.com/blog/391947/201809/391947-20180916233749134-798948486.png)

否则，可以初步得到$p[i]=mx-i$，再通过$while​$循环枚举最大区间即可。

![img](https://img2018.cnblogs.com/blog/391947/201809/391947-20180916233809298-960515229.png)

```cpp
string Manacher(string s) {
    // Insert '#'
    string t = "$#";
    for (int i = 0; i < s.size(); ++i) { //预处理
        t += s[i];
        t += "#";
    }
    // Process t
    vector<int> p(t.size(), 0); //p[i]表示以t[i]为中心的最长回文字串的半径长度
    int mx = 0, id = 0, resLen = 0, resCenter = 0;//其中id为能延伸到最右端的位置的那个回文子串的中心点位置，mx是回文串能延伸到的最右端的位置，最大半径，中心位置
    for (int i = 1; i < t.size(); ++i) {
        p[i] = mx > i ? min(p[2 * id - i], mx - i) : 1;
        while (t[i + p[i]] == t[i - p[i]]) ++p[i]; //枚举
        if (mx < i + p[i]) { 
            mx = i + p[i];
            id = i;
        }
        if (resLen < p[i]) {
            resLen = p[i];
            resCenter = i;
        }
    }
    return s.substr((resCenter - resLen) / 2, resLen - 1);
}
```

### Reference

https://www.cnblogs.com/grandyang/p/4475985.html