## 字符串算法-个人总结

### Manacher算法

此算法用于求最长回文字串，时间复杂度为$O(n)$。

令$j=2*id-i$，$j$代表$i$关于$id$对称的位置，

若$mx-i>p[j]$，则以$i$为中心的最长回文字串一定被包含于以$id$为中心的回文字串中，又因为$[id-mx,id+mx]$是回文字串，所以一定有$p[i]=p[j]$。

![img](https://img2018.cnblogs.com/blog/391947/201809/391947-20180916233749134-798948486.png)

否则，可以初步得到$p[i]=mx-i$，再通过$while$循环枚举最大区间即可。

![img](https://img2018.cnblogs.com/blog/391947/201809/391947-20180916233809298-960515229.png)

```cpp
string Manacher(string s) {
    // Insert '#'
    string t = "$#";
    for (int i = 0; i < s.size(); ++i) { //预处理
        t += s[i];
        t += "#";
    }
    // Process t
    vector<int> p(t.size(), 0); //p[i]表示以t[i]为中心的最长回文字串的半径长度
    int mx = 0, id = 0, resLen = 0, resCenter = 0;//其中id为能延伸到最右端的位置的那个回文子串的中心点位置，mx是回文串能延伸到的最右端的位置，最大半径，中心位置
    for (int i = 1; i < t.size(); ++i) {
        p[i] = mx > i ? min(p[2 * id - i], mx - i) : 1;
        while (t[i + p[i]] == t[i - p[i]]) ++p[i]; //枚举
        if (mx < i + p[i]) { 
            mx = i + p[i];
            id = i;
        }
        if (resLen < p[i]) {
            resLen = p[i];
            resCenter = i;
        }
    }
    return s.substr((resCenter - resLen) / 2, resLen - 1);
}
```

### 字符串哈希

假设有一$|S|=5$的字符串，设$S_i$为第$i$个字符，可得$Hash$数组：
$$
hash[1] = s_1\\
hash[2] = s_1 * p +s_2\\
hash[3] = s_1 * p ^ 2 +s_2 * p + s_3\\
hash[4] = s_1 * p^3 + s_2 * p^2 + s_3 * p + s_4\\
hash[5] = s_1 * p^4 + s_2 * p^3 + s_3 * p^2 + s_4 * p + s_5
$$
其中$p$为素数。现在假设要求子串$s_3s_4$的$hash$值，可知为$s_3*p+s4$。再通过上表可知道$Hash[s_3s_4]=Hash[4]-Hash[2]*p^{4-2}$。所以可得
$$
Hash[l,r]=Hash[r]-Hash[l-1]*p^{r-l+1}
$$
**可通过将数据类型设置为$unsigned\ long\ long$使其自然溢出**

```cpp
unsigned int getHash(int l,int r){
    return Hash[r]-Hash[l-1]*bin[(r-l+1)];
}
```

在值域为$[0,mod)$的数中，期望找$\sqrt mod$个数就会有两个数相等

#####常用素数表

| lwr(下界) | upr(上界) | %err(冲突率) | prime(素数) |
| --------- | :-------- | ------------ | ----------- |
| $26$      | 26        | 10.41667     | 53          |
| 26        | 27        | 1.041667     | 97          |
| 27        | 28        | 0.520833     | 193         |
| 28        | 29        | 1.302083     | 389         |
| 29        | 210       | 0.130208     | 769         |
| 210       | 211       | 0.455729     | 1543        |
| 211       | 212       | 0.227865     | 3079        |
| 212       | 213       | 0.113932     | 6151        |
| 213       | 214       | 0.008138     | 12289       |
| 214       | 215       | 0.069173     | 24593       |
| 215       | 216       | 0.010173     | 49157       |
| 216       | 217       | 0.013224     | 98317       |
| 217       | 218       | 0.002543     | 196613      |
| 218       | 219       | 0.006358     | 393241      |
| 219       | 220       | 0.000128     | 786433      |
| 220       | 221       | 0.000318     | 1572869     |
| 221       | 222       | 0.00035      | 3145739     |
| 222       | 223       | 0.000207     | 6291469     |
| 223       | 224       | 0.00004      | 12582917    |
| 224       | 225       | 0.000075     | 25165843    |
| 225       | 226       | 0.00001      | 50331653    |
| 226       | 227       | 0.000023     | 100663319   |
| 227       | 228       | 0.000009     | 201326611   |
| 228       | 229       | 0.000001     | 402653189   |
| 229       | 230       | 0.000011     | 805306457   |
| 230       | 231       | 0            | 1610612741  |

### 回文树

![img](H:\GitHub\Algorithm\字符串\C772ED42CC4B59D3BA53DE05B6FB19F6.png)

- 回文树中记录了以$s_i$字符结尾的最长回文子串，其$fail$指针指向其最长后缀回文子串。节点个数即为**本质不同**的回文子串的个数。
- 求两个字符串中相同的回文串的对数。分别从奇节点，和偶节点$dfs$下去。总回文串对数为当前层的对数+其余各层的回文串对数。

```cpp
int dfs(int p1,int p2){
    int ans=0;
    for(int i=0;i<26;i++){
        if(pam1.tree[p1][i]!=0&&pam2.tree[p2][i]!=0){
            ans+=pam1.cnt[pam1.tree[p1][i]]*pam2.cnt[pam2.tree[p2][i]]+dfs(pam1.tree[p1][i],pam2.tree[p2][i]);
        }
    }
    return ans;
}
cout<<dfs(0,0)+dfs(1,1)<<endl;
```

- 若是**求最长xx回文串**可直接从数组位置入手操作。**若没有说明**是最长回文子串，需从$fail$树向上遍历查找或新建个树，从上到下遍历查找。并按需**使用字符串哈希方法**。
- 求不相交的回文子串的对数。正反分别创建一颗回文树，即可得到以$s_i$字符为结尾的回文子串的个数和以$s_i$为起点的回文子串的个数，求一遍前缀和即可得到前$i$个字符中所有回文串的个数。则不相交的回文子串的对数等于前$i$个字符中所有回文串的个数*以$s_{i+1}$字符为起始的回文串的个数。
- 若是求相交的回文子串的对数，则可转化为求不相交的回文子串的对数。

### KMP&&exKMP

```cpp
int Next[maxn]; /*i之前相同前缀后缀的长度，例ababc,Next[5]=2; */
void getNext(int m,char p[]){
    memset(Next,0,sizeof(int)*(m+5));
    int k=-1,j=0;
    Next[0]=-1;
    while(j<m){
        if(k==-1||p[k]==p[j]){
            k++,j++;
            if(p[k]!=p[j]) Next[j]=k;
            else Next[j]=Next[k];
        }
        else k=Next[k];
    }
}
int KMP(int n,int m,char s[],char p[]){
    int i=0,j=0,ans=0;
    while(i<n){
        if(j==-1||s[i]==p[j]) i++,j++;
        else j=Next[j];
        if(j==m) ans++; /*计数（可重叠）*/
        //if(j==m) ans++,j=0;/*计数（不可重叠）*/
        //if(j==m) return i-m+1; /*返回第一个匹配的位置 */
    }
    //return j;/*返回s后缀与p前缀匹配的最长长度 */
    return ans;
}
```

- $Next$数组中，最小循环节为$k=len-Next[len]$。若$k\ne len$并且$len\ mod \ k=0$则其本身就是循环串。否则至少需要添加$k-Next[len]\ mod \ k$个字符才能使其成为循环串。
- 若求给定字符串的所有相同的前缀后缀出现的位置，则从$n$开始递归的遍历$Next[]$数组即可，即$n=Next[n]$
- 若求给定字符串的所有前缀在原串中出现的总次数，则遍历$[n,0]$，对每个位置递归遍历$Next[]$数组，每次加$1$

### Reference

https://www.cnblogs.com/grandyang/p/4475985.html

https://blog.csdn.net/pengwill97/article/details/80879387

