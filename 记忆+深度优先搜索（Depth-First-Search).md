# 记忆+深度优先搜索（Depth-First-Search)

## DFS原理：

此算法的核心便在于深度优先四个字，什么意思呢？比如在一棵树形图中，我们先选择向左走，那么在深度优先搜索中，只要能继续向左走，就一直走下去，一直到无路可走的时候才会选择向右走，如果向右也无路可走那么便回到上一次的状态。直到遍历完所有的节点。如下图：![DFS](C:\Users\asus\Desktop\DFS.gif)

深搜还有一个注意点，比如我们用深搜求此树形图的最长路径时，只有走到无路可走时，才开始统计路径长度。

下面我们看一个具体的题目：

##[Poj-1088-滑雪](http://poj.org/problem?id=1088])

###`Description `

>  Michael喜欢滑雪百这并不奇怪，  因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子 
>
> ```
>  1  2  3  4 5
> 
> 16 17 18 19 6
> 
> 15 24 25 20 7
> 
> 14 23 22 21 8
> 
> 13 12 11 10 9
> ```

> 一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-...-3-2-1更长。事实上，这是最长的一条。 

###`Input `

> 输入的第一行表示区域的行数R和列数C(1 <= R,C <= 100)。下面是R行，每行有C个整数，代表高度h，0<=h<=10000。 

###`Output `

> 输出最长区域的长度。 

## `Sample Input`

> ```
> 5 5
> 1 2 3 4 5
> 16 17 18 19 6
> 15 24 25 20 7
> 14 23 22 21 8
> 13 12 11 10 9
> ```

###`Sample Output`

> ```
> 25
> ```

###`Source `

> [SHTSC 2002](http://poj.org/searchproblem?field=source&key=SHTSC+2002)

### `题解`

> 题意：在一个矩阵中，每一个点可以往上下左右四个方向中比当前位置小的点移动，求最⻓路路径。遍历，对于矩阵中的每个点，搜索它的上下左右四个点的高度是否小于当前点的⾼高度，如果满⾜足，对该⽅方向递归搜索，递归结束后，返回上下左右四个点的最大值，最后返回的就是从该点开始的最⻓路径⻓度，答案就是它们的最大值。
> 直接暴暴⼒ DFS 会 TLE，需要记忆化搜索，即在每次递归结束后，把改点的最长路径长度保存起来，在下次递归到改点时可以直接调用。

###`AC代码`

```c++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
int a[105][105];           
bool vis[105][105];      	//标记当前点是否访问过
int path[4][2] = {1, 0, -1, 0, 0, -1, 0, 1};  	//4个方向：下，上，左，右
int mem[105][105];         //记忆化数组，表示从第x行y列开始的最长下降序列的长度
int r, c;
bool checkedge(int xx, int yy)  //判断此点是否遍历过，或者该点是否在所给范围内
{
    if (xx >= 1 && xx <= r && yy >= 1 && yy <= c && !vis[xx][yy])
    {
        return 1;
    }
    else
        return 0;
}
int Max = 0;
int dfs(int x, int y)   //从深度优先方面考虑，遍历到无路可走或者到一个已经搜过的点时才开始计数
{

    if (mem[x][y])       //如果当前点已经搜过，直接返回其值
    {
        return mem[x][y];
    }
    int tmp = 0;
    for (int i = 0; i < 4; i++)    //四个方向
    {
        int xx = path[i][0] + x;   //下一个位置
        int yy = path[i][1] + y;
        if (checkedge(xx, yy) && a[xx][yy] < a[x][y])   //下一个位置的高度需小于当前位置的高度
        {
            vis[xx][yy] = 1;		//标记当前位置为已遍历
            tmp = max(tmp, dfs(xx, yy));   //遍历出所有分路里最大的一个
            vis[xx][yy] = 0;		//取消标记，以便于从其他路径遍历该点
        }
    }
    mem[x][y] = tmp + 1;    //当前值为所有分路最大值+1(即加上当前位置)
    return tmp + 1;     //返回当前路径的值
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> r >> c;
    for (int i = 1; i <= r; i++)
    {
        for (int j = 1; j <= c; j++)
        {
            cin >> a[i][j];
        }
    }
    for (int i = 1; i <= r; i++)	
    {
        for (int j = 1; j <= c; j++)
        {
            memset(vis, 0, sizeof(vis));	//遍历时，需先初始化vis数组
            vis[i][j] = 1;				
            Max = max(Max, dfs(i, j));     //遍历所有点，求出最大值
        }
    }
    cout << Max << endl;
    return 0;
}
```

